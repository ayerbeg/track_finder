#include <iostream>
#include "string.h"
#include "TFile.h"
#include "TTree.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TCanvas.h"
#include "TGraph.h"
#include "math.h"
#include "chain_finder.h"




/* The status bits for hits in the hitlists */
#define HUNTCHD 0  /* - untouched - no status set yet */
#define HISUSED 1  /* - (was 1) used */
#define HREMOVD 2  /* - (was 2)removed for high residual to helix */
#define HDISEAR 4  /* - t<TPC_TMIN */
#define HDISLAT 8  /* - t>TPC_TMAX */
#define HEARLST 0x10  /* - this hit is has earliest time for this pad on this chain */
#define HABSORB 0x20  /* - hit absorbed in routine weightData */
#define HSMALLQ 0x40  /* - (was -3) charge < THR_Q_LINK */
#define HITTEMP 0x80  /* for routine-specific status marks. */
#define FAKE_HIT 0x100 /* any type of artificially-generated hit */
#define PROJECTED_HIT 0x200 /* indicates a hit generated by projecting fitted track */
#define SWUMHIT 0x400 /* indicates a hit generated by swimming the track */
#define HBADPAD 0x800 /* hit is on a pad marked as bad */
#define HITUNAV (HISUSED|HDISEAR|HDISLAT|HABSORB|HSMALLQ|FAKE_HIT|HBADPAD) /* reasons to NOT use a hit in the chain-linker */



void chain_finder()
{


  //GLOBAL VARIABLES HERE
  Bool_t VERBOSE = 0;
  
  gStyle->SetOptStat(1);

  Double_t rad2deg = 180/(4*atan(1));



  

  

  
  Int_t    steps;
  Int_t    steps_temp, rsteps;//I need this variable 
  Int_t    fIndex;
 


  Double_t xrec[ndim],yrec[ndim],zrec[ndim];
  Double_t x[ndim],y[ndim],z[ndim];

 
  Double_t fEdep , time;

  Double_t fkineEne;
  Int_t    fPid;
  Double_t fTheta;
  Double_t fPhi;

  
  //********************************
  // DEFINE VARIABLES FROM ROOT FILE
  
  TFile *infile = new TFile("1000SuperEvents.root");
  RTPCTree=(TTree*)infile->Get("eventtree");
  
  Int_t Entries = RTPCTree->GetEntries();
  cout<<"Entries: "<<Entries<<endl;
  
  RTPCTree ->SetBranchAddress("event", &fIndex);
  RTPCTree ->SetBranchAddress("Hit", &fHit);
  RTPCTree ->SetBranchAddress("X", &fXRec[steps]);
  RTPCTree ->SetBranchAddress("Y", &fYRec[steps]);
  RTPCTree ->SetBranchAddress("Z", &fZRec[steps]);
  //********************************


  //***********************************
  // DEFINE VARIABLES TO SAVE ROOT FILE
  
  TFile *rootoutfile = new TFile("ChainEvents.root", "recreate");
  
  TTree *chaintree = new TTree("chaintree","SE");
  
  chaintree->Branch("event", &ChainEv.ID, "ID/I");  // Create a branch called a, linked to local variable x, of type D (double)
  chaintree->Branch("X", ChainEv.X_rec, "X_rec[500]/D");
  chaintree->Branch("Y", ChainEv.Y_rec, "Y_rec[500]/D");
  chaintree->Branch("Z", ChainEv.Z_rec, "Z_rec[500]/D");
  chaintree->Branch("Hit", &ChainEv.Hit, "Hit/I");
  
  //***********************************


  
  //LOOP TO READ THE VARIABLES FROM THE ROOT FILE

  //here we are reading the whole file, which has many superevents
  //perhaps we want to read one event at the time, for test purposes.

  //In general, this is a track/chain finder, so this code only FILTER
  // and its output should be individuals chains to be analyzed later
  // with the Kalman Filter or something else.

  //TERMS:
  //anchor: the hit to start the search
  //
  
  anchor_hit = 0;
  num_chains = 0;
  num_hits_this_chain[0] = 0;

  EvID = 0;
  
  
  //   for(Int_t i = 0; i < Entries; i++)  //uncomment for the whole file.
  for(Int_t i = 4; i < 7; i++) 
    {

      readout(i);//Read the event and store in the struct variables

      cout<<maxin<<endl;
      
      for (anchor_hit = 0; anchor_hit < maxin; anchor_hit++) //index of anchor hit
	{
	  //we are reading to the total hits in the event. Perhaps I could read the whole event and see HOW many
	  //good events I have. With this I remove the zeros in the tail of the event
	  
	  //	cout<<"hello "<<endl;
	  
	  if( (hitevent[anchor_hit].Status & HITUNAV) && hitevent[anchor_hit].Ev_pos == 2); //If Status=1 (used), do not do anyhthing. With the condition Ev_pos, we stop the search of hots on the second events. We just connect the first with events related on the second
	    {
	      //
	    }
	  else
	    {
	      num_hits_this_chain[num_chains] = 1;
	      chain_hits[num_chains][0] = anchor_hit;
	      
	      hitevent[anchor_hit].Status |= HISUSED;
	      
	      
	      for (seed_hit = 0; seed_hit < num_hits_this_chain[num_chains]; seed_hit++)
		{
		  seed_index = chain_hits[num_chains][seed_hit];
		  
		  pseed[0] = hitevent[seed_index].X;
		  pseed[1] = hitevent[seed_index].Y;
		  pseed[2] = hitevent[seed_index].Z;
		  
		  
		  // cout<<"index: "<<num_hits_this_chain[num_chains]<<endl;
		  // cout<<"**********pseed[0]: "<<pseed[0]<<" pseed[1]: "<<pseed[1]<<" pseed[2]: "<<pseed[2]<<endl<<endl;
		  
		  //		  for(next_hit = 0; next_hit<fHit; next_hit++)
		  for(next_hit = 0; next_hit<(aHit[0]+aHit[1]); next_hit++)//the max number of hits is the sum of two events hits
		    {
		      if( !(hitevent[next_hit].Status & HITUNAV) )
			{
			  
			  pnext[0] = hitevent[next_hit].X;
			  pnext[1] = hitevent[next_hit].Y;
			  pnext[2] = hitevent[next_hit].Z;
					    
			  SUBST(pseed, pnext, diff);
			  
			  separation = DIFMOD(diff);
			  
			  if(separation <= MAX_LINK_SEP && separation > 0)
			    {
			      //	    add it to the current chain
			      if (num_hits_this_chain[num_chains] >= MAX_HITS_ON_CHAIN)
				{        
				  printf("Too many hits for the chain list. Aborting.\n"); 
				  return -1;
				}
			      
			      chain_hits[num_chains][num_hits_this_chain[num_chains]] = next_hit;
			      
			      /* mark it as used */
			      hitevent[next_hit].Status |= HISUSED;
			      num_hits_this_chain[num_chains]++;
			      
			    }// if(separation

			  else
			    {}
			  
			}// if( !(hitevent
		      
		    }// for(next_hit
		  
		  
		  else
		    {}
		  
		  
		}//  for (seed_hit
	      
	  HitIn = 0;// It is initialized before enter the loop to fill the root file
	  
	  if( num_hits_this_chain[num_chains] > 1) 
	    {
	      if(1)
		{
		  printf("....KEEPING THIS CHAIN #%d. %d hits \n", num_chains,num_hits_this_chain[num_chains]);
		  
		  
		  for (Int_t jj=0; jj<num_hits_this_chain[num_chains]; jj++)
		    {
		      printf(" %d", chain_hits[num_chains][jj]);
			  
		      //Fill the variables value of the found chain
			  ChainEv.X_rec[HitIn] = hitevent[chain_hits[num_chains][jj]].X;
			  ChainEv.Y_rec[HitIn] = hitevent[chain_hits[num_chains][jj]].Y;
			  ChainEv.Z_rec[HitIn] = hitevent[chain_hits[num_chains][jj]].Z;
			  cout<<" X: "<<hitevent[chain_hits[num_chains][jj]].X<<endl;;
			  HitIn++; 
			  
			}

		      for(Int_t kk=HitIn; kk<500;kk++)	//Clean up loop
			{
			  ChainEv.X_rec[kk]=ChainEv.Y_rec[kk]=ChainEv.Z_rec[kk]=0;
			}
		      
		      ChainEv.Hit = HitIn;
		      ChainEv.ID = EvId; //Event Index. A Chain per index
		      chaintree->Fill();
		      
		      EvId++;
		      
		      printf("\n\n");
		      
		    }
		  
		  num_chains++; /* save chain if >1 hit on it */
		}
	      else
		{
		  hitevent[next_hit].Status &= ~HISUSED;
		}
	      
	      
	      
	      
	    }//else (from if( hitevent[anchor_hit].Status & HITUNAV)
	  
	}//for(anchor_hit...



    }

    chaintree->Write();
    rootoutfile->Close();

}





double SUBST(Double_t seed[], Double_t next[], Double_t dif[])
{
  for(Int_t q = 0; q<3; q++)
    {
      dif[q] = seed[q] - next[q];
    }
  
  return dif;
  
}


double DIFMOD(Double_t dif[])
{
  
  Double_t tmp = 0;

  for(Int_t q = 0; q<3; q++)
    {
      tmp = tmp+(dif[q] * dif[q]);
    }

  if (tmp < 0) return 0;

  return sqrt(tmp);


  
}



void readout(Int_t i)
{

  maxin = 0;

      // for(Int_t p = 0; p<ndim; p++)
      // 	{
      // 	  hitevent[p].X = 0;
      // 	  hitevent[p].Y = 0;
      // 	  hitevent[p].Z = 0;
      // 	}//cleaning loop
  
      RTPCTree->GetEntry(i);
      RTPCTree->Show(i,fHit);

      Int_t in = 0;
      aHit[0]=fHit;



      

      
      for(Int_t p = 0; p<aHit[0]; p++)
	{
	  //	  cout<<"X: "<<fXRec[p]<<" Y; "<< fYRec[p] << " Z: " <<fZRec[p] <<endl;
	  if (i>4)
	    {
	      if (hitevent[p+aHit[0]].Status = 0)//This condition, check if the event read joint previously has marked hits
		{
		  hitevent[p].X = fXRec[p];
		  hitevent[p].Y = fYRec[p];
		  hitevent[p].Z = fZRec[p];
		  hitevent[p].Status = 0;
		  hitevent[p].Ev_pos = 1;
		  maxin++;
		}
	      else
		{
		  hitevent[p].Status = 1;
		  hitevent[p].Ev_pos = 1;
		  maxin++;
		  //	      cout<<"HELLO"<<p<<endl;
		}
	    }
	  else
	    {
	      hitevent[p].X = fXRec[p];
	      hitevent[p].Y = fYRec[p];
	      hitevent[p].Z = fZRec[p];
	      hitevent[p].Status = 0;
	      hitevent[p].Ev_pos = 1;
	      maxin++;
	    }
	}

      RTPCTree->GetEntry(i+1);
      RTPCTree->Show(i+1,fHit);
      aHit[1]=fHit;

      
      for(Int_t p = aHit[0]; p<(aHit[0]+aHit[1]); p++)
      	{
	  //	  cout<<"p2: "<<p<<endl;

	  //	  cout<<"X: "<<fXRec[p-aHit[0]]<<" Y; "<< fYRec[p-aHit[0]] << " Z: " <<fZRec[p-aHit[0]] <<endl;
	  hitevent[p].X = fXRec[p-aHit[0]];
	  hitevent[p].Y = fYRec[p-aHit[0]];
	  hitevent[p].Z = fZRec[p-aHit[0]];
	  hitevent[p].Status = 0;
	  hitevent[p].Ev_pos = 2;
	  maxin++;
	  
      	}
      
      cout<<"******************************IN***********************:"<<maxin<<endl;
      //       RTPCTree->Show(i);
   
}


void savedata(Int_t k)
{
  

}
